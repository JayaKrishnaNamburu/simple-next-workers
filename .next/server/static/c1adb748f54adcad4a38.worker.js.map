{"version":3,"file":"static/c1adb748f54adcad4a38.worker.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/comlink/dist/umd/comlink.js","webpack:///./utils/simple.worker.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tvar threw = true;\n \t\ttry {\n \t\t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n \t\t\tthrew = false;\n \t\t} finally {\n \t\t\tif(threw) delete installedModules[moduleId];\n \t\t}\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/next/dist/build/webpack/loaders/next-babel-loader.js?!./utils/simple.worker.js\");\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.Comlink = {}));\n}(this, (function (exports) { 'use strict';\n\n  /**\r\n   * Copyright 2019 Google Inc. All Rights Reserved.\r\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   * you may not use this file except in compliance with the License.\r\n   * You may obtain a copy of the License at\r\n   *     http://www.apache.org/licenses/LICENSE-2.0\r\n   * Unless required by applicable law or agreed to in writing, software\r\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   * See the License for the specific language governing permissions and\r\n   * limitations under the License.\r\n   */\r\n  const proxyMarker = Symbol(\"Comlink.proxy\");\r\n  const createEndpoint = Symbol(\"Comlink.endpoint\");\r\n  const releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\n  const throwSet = new WeakSet();\r\n  const transferHandlers = new Map([\r\n      [\r\n          \"proxy\",\r\n          {\r\n              canHandle: obj => obj && obj[proxyMarker],\r\n              serialize(obj) {\r\n                  const { port1, port2 } = new MessageChannel();\r\n                  expose(obj, port1);\r\n                  return [port2, [port2]];\r\n              },\r\n              deserialize: (port) => {\r\n                  port.start();\r\n                  return wrap(port);\r\n              }\r\n          }\r\n      ],\r\n      [\r\n          \"throw\",\r\n          {\r\n              canHandle: obj => throwSet.has(obj),\r\n              serialize(obj) {\r\n                  const isError = obj instanceof Error;\r\n                  let serialized = obj;\r\n                  if (isError) {\r\n                      serialized = {\r\n                          isError,\r\n                          message: obj.message,\r\n                          stack: obj.stack\r\n                      };\r\n                  }\r\n                  return [serialized, []];\r\n              },\r\n              deserialize(obj) {\r\n                  if (obj.isError) {\r\n                      throw Object.assign(new Error(), obj);\r\n                  }\r\n                  throw obj;\r\n              }\r\n          }\r\n      ]\r\n  ]);\r\n  function expose(obj, ep = self) {\r\n      ep.addEventListener(\"message\", function callback(ev) {\r\n          if (!ev || !ev.data) {\r\n              return;\r\n          }\r\n          const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n          const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n          let returnValue;\r\n          try {\r\n              const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n              const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n              switch (type) {\r\n                  case 0 /* GET */:\r\n                      {\r\n                          returnValue = rawValue;\r\n                      }\r\n                      break;\r\n                  case 1 /* SET */:\r\n                      {\r\n                          parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                          returnValue = true;\r\n                      }\r\n                      break;\r\n                  case 2 /* APPLY */:\r\n                      {\r\n                          returnValue = rawValue.apply(parent, argumentList);\r\n                      }\r\n                      break;\r\n                  case 3 /* CONSTRUCT */:\r\n                      {\r\n                          const value = new rawValue(...argumentList);\r\n                          returnValue = proxy(value);\r\n                      }\r\n                      break;\r\n                  case 4 /* ENDPOINT */:\r\n                      {\r\n                          const { port1, port2 } = new MessageChannel();\r\n                          expose(obj, port2);\r\n                          returnValue = transfer(port1, [port1]);\r\n                      }\r\n                      break;\r\n                  case 5 /* RELEASE */:\r\n                      {\r\n                          returnValue = undefined;\r\n                      }\r\n                      break;\r\n              }\r\n          }\r\n          catch (e) {\r\n              returnValue = e;\r\n              throwSet.add(e);\r\n          }\r\n          Promise.resolve(returnValue)\r\n              .catch(e => {\r\n              throwSet.add(e);\r\n              return e;\r\n          })\r\n              .then(returnValue => {\r\n              const [wireValue, transferables] = toWireValue(returnValue);\r\n              ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n              if (type === 5 /* RELEASE */) {\r\n                  // detach and deactive after sending release response above.\r\n                  ep.removeEventListener(\"message\", callback);\r\n                  closeEndPoint(ep);\r\n              }\r\n          });\r\n      });\r\n      if (ep.start) {\r\n          ep.start();\r\n      }\r\n  }\r\n  function isMessagePort(endpoint) {\r\n      return endpoint.constructor.name === \"MessagePort\";\r\n  }\r\n  function closeEndPoint(endpoint) {\r\n      if (isMessagePort(endpoint))\r\n          endpoint.close();\r\n  }\r\n  function wrap(ep, target) {\r\n      return createProxy(ep, [], target);\r\n  }\r\n  function throwIfProxyReleased(isReleased) {\r\n      if (isReleased) {\r\n          throw new Error(\"Proxy has been released and is not useable\");\r\n      }\r\n  }\r\n  function createProxy(ep, path = [], target = function () { }) {\r\n      let isProxyReleased = false;\r\n      const proxy = new Proxy(target, {\r\n          get(_target, prop) {\r\n              throwIfProxyReleased(isProxyReleased);\r\n              if (prop === releaseProxy) {\r\n                  return () => {\r\n                      return requestResponseMessage(ep, {\r\n                          type: 5 /* RELEASE */,\r\n                          path: path.map(p => p.toString())\r\n                      }).then(() => {\r\n                          closeEndPoint(ep);\r\n                          isProxyReleased = true;\r\n                      });\r\n                  };\r\n              }\r\n              if (prop === \"then\") {\r\n                  if (path.length === 0) {\r\n                      return { then: () => proxy };\r\n                  }\r\n                  const r = requestResponseMessage(ep, {\r\n                      type: 0 /* GET */,\r\n                      path: path.map(p => p.toString())\r\n                  }).then(fromWireValue);\r\n                  return r.then.bind(r);\r\n              }\r\n              return createProxy(ep, [...path, prop]);\r\n          },\r\n          set(_target, prop, rawValue) {\r\n              throwIfProxyReleased(isProxyReleased);\r\n              // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n              // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n              const [value, transferables] = toWireValue(rawValue);\r\n              return requestResponseMessage(ep, {\r\n                  type: 1 /* SET */,\r\n                  path: [...path, prop].map(p => p.toString()),\r\n                  value\r\n              }, transferables).then(fromWireValue);\r\n          },\r\n          apply(_target, _thisArg, rawArgumentList) {\r\n              throwIfProxyReleased(isProxyReleased);\r\n              const last = path[path.length - 1];\r\n              if (last === createEndpoint) {\r\n                  return requestResponseMessage(ep, {\r\n                      type: 4 /* ENDPOINT */\r\n                  }).then(fromWireValue);\r\n              }\r\n              // We just pretend that `bind()` didn’t happen.\r\n              if (last === \"bind\") {\r\n                  return createProxy(ep, path.slice(0, -1));\r\n              }\r\n              const [argumentList, transferables] = processArguments(rawArgumentList);\r\n              return requestResponseMessage(ep, {\r\n                  type: 2 /* APPLY */,\r\n                  path: path.map(p => p.toString()),\r\n                  argumentList\r\n              }, transferables).then(fromWireValue);\r\n          },\r\n          construct(_target, rawArgumentList) {\r\n              throwIfProxyReleased(isProxyReleased);\r\n              const [argumentList, transferables] = processArguments(rawArgumentList);\r\n              return requestResponseMessage(ep, {\r\n                  type: 3 /* CONSTRUCT */,\r\n                  path: path.map(p => p.toString()),\r\n                  argumentList\r\n              }, transferables).then(fromWireValue);\r\n          }\r\n      });\r\n      return proxy;\r\n  }\r\n  function myFlat(arr) {\r\n      return Array.prototype.concat.apply([], arr);\r\n  }\r\n  function processArguments(argumentList) {\r\n      const processed = argumentList.map(toWireValue);\r\n      return [processed.map(v => v[0]), myFlat(processed.map(v => v[1]))];\r\n  }\r\n  const transferCache = new WeakMap();\r\n  function transfer(obj, transfers) {\r\n      transferCache.set(obj, transfers);\r\n      return obj;\r\n  }\r\n  function proxy(obj) {\r\n      return Object.assign(obj, { [proxyMarker]: true });\r\n  }\r\n  function windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n      return {\r\n          postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n          addEventListener: context.addEventListener.bind(context),\r\n          removeEventListener: context.removeEventListener.bind(context)\r\n      };\r\n  }\r\n  function toWireValue(value) {\r\n      for (const [name, handler] of transferHandlers) {\r\n          if (handler.canHandle(value)) {\r\n              const [serializedValue, transferables] = handler.serialize(value);\r\n              return [\r\n                  {\r\n                      type: 3 /* HANDLER */,\r\n                      name,\r\n                      value: serializedValue\r\n                  },\r\n                  transferables\r\n              ];\r\n          }\r\n      }\r\n      return [\r\n          {\r\n              type: 0 /* RAW */,\r\n              value\r\n          },\r\n          transferCache.get(value) || []\r\n      ];\r\n  }\r\n  function fromWireValue(value) {\r\n      switch (value.type) {\r\n          case 3 /* HANDLER */:\r\n              return transferHandlers.get(value.name).deserialize(value.value);\r\n          case 0 /* RAW */:\r\n              return value.value;\r\n      }\r\n  }\r\n  function requestResponseMessage(ep, msg, transfers) {\r\n      return new Promise(resolve => {\r\n          const id = generateUUID();\r\n          ep.addEventListener(\"message\", function l(ev) {\r\n              if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                  return;\r\n              }\r\n              ep.removeEventListener(\"message\", l);\r\n              resolve(ev.data);\r\n          });\r\n          if (ep.start) {\r\n              ep.start();\r\n          }\r\n          ep.postMessage(Object.assign({ id }, msg), transfers);\r\n      });\r\n  }\r\n  function generateUUID() {\r\n      return new Array(4)\r\n          .fill(0)\r\n          .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n          .join(\"-\");\r\n  }\n\n  exports.createEndpoint = createEndpoint;\n  exports.expose = expose;\n  exports.proxy = proxy;\n  exports.proxyMarker = proxyMarker;\n  exports.releaseProxy = releaseProxy;\n  exports.transfer = transfer;\n  exports.transferHandlers = transferHandlers;\n  exports.windowEndpoint = windowEndpoint;\n  exports.wrap = wrap;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=comlink.js.map\n","import { expose } from \"comlink\";\n\nconst greeting = () => {\n  return \"Hello\";\n};\n\nexpose({\n  greeting\n});\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxFA;AACA;AACA,WACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnTA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;;;;A","sourceRoot":""}